{"ast":null,"code":"Object.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar React = require('react');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar throttle = function (callback, limit) {\n  var tick = false;\n  return function () {\n    if (!tick) {\n      callback();\n      tick = true;\n      setTimeout(function () {\n        tick = false;\n      }, limit);\n    }\n  };\n};\n\nvar ScrollSpy = function (_a) {\n  var _b;\n\n  var children = _a.children,\n      // refs\n  navContainerRef = _a.navContainerRef,\n      parentScrollContainerRef = _a.parentScrollContainerRef,\n      // throttle\n  _c = _a.scrollThrottle,\n      // throttle\n  scrollThrottle = _c === void 0 ? 300 : _c,\n      // callback\n  onUpdateCallback = _a.onUpdateCallback,\n      // offsets\n  _d = _a.offsetTop,\n      // offsets\n  offsetTop = _d === void 0 ? 0 : _d,\n      _e = _a.offsetBottom,\n      offsetBottom = _e === void 0 ? 0 : _e,\n      // customize attributes\n  _f = _a.useDataAttribute,\n      // customize attributes\n  useDataAttribute = _f === void 0 ? \"to-scrollspy-id\" : _f,\n      _g = _a.activeClass,\n      activeClass = _g === void 0 ? \"active-scroll-spy\" : _g,\n      _h = _a.useBoxMethod,\n      useBoxMethod = _h === void 0 ? true : _h;\n  var scrollContainerRef = React.useRef(null);\n\n  var _j = React.useState(),\n      navContainerItems = _j[0],\n      setNavContainerItems = _j[1]; // prettier-ignore\n  // keeps track of the Id in navcontainer which is active\n  // so as to not update classLists unless it has been updated\n\n\n  var prevIdTracker = React.useRef(\"\"); // To get the nav container items depending on whether the parent ref for the nav container is passed or not\n\n  React.useEffect(function () {\n    var _a;\n\n    navContainerRef ? setNavContainerItems((_a = navContainerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"[data-\" + useDataAttribute + \"]\")) : setNavContainerItems(document.querySelectorAll(\"[data-\" + useDataAttribute + \"]\")); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerRef]); // fire once after nav container items are set\n\n  React.useEffect(function () {\n    checkAndUpdateActiveScrollSpy(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerItems]);\n\n  var isVisible = function (el) {\n    var rectInView = el.getBoundingClientRect();\n\n    if (useBoxMethod) {\n      var useHeight = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight : window.innerHeight;\n      var hitbox_top = useHeight;\n      var element_top = rectInView.top;\n      var element_bottom = rectInView.top + useHeight;\n      return hitbox_top < element_bottom + offsetBottom && hitbox_top > element_top - offsetTop;\n    } else {\n      // this decides how much of the element should be visible\n      var leniency = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight) * 0.5 : window.innerHeight * 0.5;\n      var useHeight = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight : window.innerHeight;\n      return rectInView.top + leniency + offsetTop >= 0 && rectInView.bottom - leniency - offsetBottom <= useHeight;\n    }\n  };\n\n  var checkAndUpdateActiveScrollSpy = function () {\n    var scrollParentContainer = scrollContainerRef.current; // if there are no children, return\n\n    if (!(scrollParentContainer && navContainerItems)) return;\n\n    var _loop_1 = function (i) {\n      // get child element\n      var useChild = scrollParentContainer.children.item(i);\n      var elementIsVisible = isVisible(useChild); // check if the element is in the viewport\n\n      if (elementIsVisible) {\n        // if so, get its ID\n        var changeHighlightedItemId_1 = useChild.id; // if the element was same as the one currently active ignore it\n\n        if (prevIdTracker.current === changeHighlightedItemId_1) return {\n          value: void 0\n        }; // now loop over each element in the nav Container\n\n        navContainerItems.forEach(function (el) {\n          var attrId = el.getAttribute(\"data-\" + useDataAttribute); // if the element contains 'active' the class remove it\n\n          if (el.classList.contains(activeClass)) {\n            el.classList.remove(activeClass);\n          } // check if its ID matches the ID we got from the viewport\n          // also make sure it does not already contain the 'active' class\n\n\n          if (attrId === changeHighlightedItemId_1 && !el.classList.contains(activeClass)) {\n            el.classList.add(activeClass);\n\n            if (onUpdateCallback) {\n              onUpdateCallback(changeHighlightedItemId_1);\n            }\n\n            prevIdTracker.current = changeHighlightedItemId_1;\n            window.history.pushState({}, \"\", \"#\" + changeHighlightedItemId_1);\n          }\n        });\n        return \"break\";\n      }\n    }; // loop over all children in scroll container\n\n\n    for (var i = 0; i < scrollParentContainer.children.length; i++) {\n      var state_1 = _loop_1(i);\n\n      if (typeof state_1 === \"object\") return state_1.value;\n      if (state_1 === \"break\") break;\n    }\n  }; // listen for scroll event\n\n\n  parentScrollContainerRef ? // if ref for scrollable div is provided\n  (_b = parentScrollContainerRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"scroll\", throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)) : // else listen for scroll in window\n  window.addEventListener(\"scroll\", throttle(checkAndUpdateActiveScrollSpy, scrollThrottle));\n  return React__namespace.createElement(\"div\", {\n    ref: scrollContainerRef\n  }, children);\n};\n\nexports[\"default\"] = ScrollSpy;","map":{"version":3,"sources":["../src/utils/throttle.ts","../src/ScrollSpy/ScrollSpy.tsx"],"names":["useRef","useState","useEffect","React"],"mappings":"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","sourcesContent":["export const throttle = (callback: () => void, limit: number) => {\n  var tick = false;\n\n  return () => {\n    if (!tick) {\n      callback();\n      tick = true;\n      setTimeout(function () {\n        tick = false;\n      }, limit);\n    }\n  };\n};\n","import * as React from \"react\";\nimport {\n  MutableRefObject,\n  ReactNode,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { throttle } from \"../utils/throttle\";\n\ninterface ScrollSpyProps {\n  children: ReactNode;\n\n  // refs\n  navContainerRef?: MutableRefObject<HTMLDivElement | null>;\n  parentScrollContainerRef?: MutableRefObject<HTMLDivElement | null>;\n\n  // throttle\n  scrollThrottle?: number;\n\n  // callback\n  onUpdateCallback?: (id: string) => void;\n\n  // offsets\n  offsetTop?: number;\n  offsetBottom?: number;\n\n  // customize attributes\n  useDataAttribute?: string;\n  activeClass?: string;\n\n  useBoxMethod?: boolean;\n}\n\nconst ScrollSpy = ({\n  children,\n\n  // refs\n  navContainerRef,\n  parentScrollContainerRef,\n\n  // throttle\n  scrollThrottle = 300,\n\n  // callback\n  onUpdateCallback,\n\n  // offsets\n  offsetTop = 0,\n  offsetBottom = 0,\n\n  // customize attributes\n  useDataAttribute = \"to-scrollspy-id\",\n  activeClass = \"active-scroll-spy\",\n\n  useBoxMethod = true,\n}: ScrollSpyProps) => {\n  const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n  const [navContainerItems, setNavContainerItems] = useState<NodeListOf<Element> | undefined>(); // prettier-ignore\n\n  // keeps track of the Id in navcontainer which is active\n  // so as to not update classLists unless it has been updated\n  const prevIdTracker = useRef(\"\");\n\n  // To get the nav container items depending on whether the parent ref for the nav container is passed or not\n  useEffect(() => {\n    navContainerRef\n      ? setNavContainerItems(\n          navContainerRef.current?.querySelectorAll(\n            `[data-${useDataAttribute}]`\n          )\n        )\n      : setNavContainerItems(\n          document.querySelectorAll(`[data-${useDataAttribute}]`)\n        );\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerRef]);\n\n  // fire once after nav container items are set\n  useEffect(() => {\n    checkAndUpdateActiveScrollSpy();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerItems]);\n\n  const isVisible = (el: HTMLElement) => {\n    const rectInView = el.getBoundingClientRect();\n\n    if (useBoxMethod) {\n      const useHeight = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight\n        : window.innerHeight;\n      const hitbox_top = useHeight;\n      const element_top = rectInView.top;\n      const element_bottom = rectInView.top + useHeight;\n\n      return (\n        hitbox_top < element_bottom + offsetBottom &&\n        hitbox_top > element_top - offsetTop\n      );\n    } else {\n      // this decides how much of the element should be visible\n      const leniency = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight * 0.5\n        : window.innerHeight * 0.5;\n\n      const useHeight = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight\n        : window.innerHeight;\n\n      return (\n        rectInView.top + leniency + offsetTop >= 0 &&\n        rectInView.bottom - leniency - offsetBottom <= useHeight\n      );\n    }\n  };\n\n  const checkAndUpdateActiveScrollSpy = () => {\n    const scrollParentContainer = scrollContainerRef.current;\n\n    // if there are no children, return\n    if (!(scrollParentContainer && navContainerItems)) return;\n\n    // loop over all children in scroll container\n    for (let i = 0; i < scrollParentContainer.children.length; i++) {\n      // get child element\n      const useChild = scrollParentContainer.children.item(i) as HTMLDivElement;\n\n      const elementIsVisible = isVisible(useChild);\n\n      // check if the element is in the viewport\n      if (elementIsVisible) {\n        // if so, get its ID\n        const changeHighlightedItemId = useChild.id;\n\n        // if the element was same as the one currently active ignore it\n        if (prevIdTracker.current === changeHighlightedItemId) return;\n\n        // now loop over each element in the nav Container\n        navContainerItems.forEach((el) => {\n          const attrId = el.getAttribute(`data-${useDataAttribute}`);\n\n          // if the element contains 'active' the class remove it\n          if (el.classList.contains(activeClass)) {\n            el.classList.remove(activeClass);\n          }\n\n          // check if its ID matches the ID we got from the viewport\n          // also make sure it does not already contain the 'active' class\n          if (\n            attrId === changeHighlightedItemId &&\n            !el.classList.contains(activeClass)\n          ) {\n            el.classList.add(activeClass);\n\n            if (onUpdateCallback) {\n              onUpdateCallback(changeHighlightedItemId);\n            }\n\n            prevIdTracker.current = changeHighlightedItemId;\n            window.history.pushState({}, \"\", `#${changeHighlightedItemId}`);\n          }\n        });\n        break;\n      }\n    }\n  };\n\n  // listen for scroll event\n  parentScrollContainerRef\n    ? // if ref for scrollable div is provided\n      parentScrollContainerRef.current?.addEventListener(\n        \"scroll\",\n        throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)\n      )\n    : // else listen for scroll in window\n      window.addEventListener(\n        \"scroll\",\n        throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)\n      );\n\n  return <div ref={scrollContainerRef}>{children}</div>;\n};\n\nexport default ScrollSpy;\n"]},"metadata":{},"sourceType":"script"}